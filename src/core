from flask import Flask, session, abort, redirect, url_for, request, render_template
import google.auth.transport
import google.auth.transport.requests
from google_auth_oauthlib.flow import Flow
import os
import pathlib
import requests
import google.auth  # google.auth --> library that helps manage authentication in Python
from google.oauth2 import id_token
import google.auth
from google.auth.transport.requests import Request
from cachecontrol import CacheControl
import mysql.connector
import json


#--------------------------------- Nhung thu phuc vu cac ham ben duoi-----------------------------------------


# pathlib.Path(__file__) --> get full path of cur file --> src/js/core/gg_auth.py
app = Flask("AuthGoogle",
            template_folder= os.path.join(pathlib.Path(__file__).parent.parent.parent, "pages"),   # in file hold template
            static_folder= os.path.join(pathlib.Path(__file__).parent.parent.parent, "css"))    
app.secret_key = "AuthGoogle"

os.environ["OAUTHLIB_INSECURE_TRANSPORT"] = "1"  # Allow HTTP for testing purposes.
GOOGLE_CLIENT_ID = "698773466958-s0aa126m3nbb0165d6qlego15pkhedcj.apps.googleusercontent.com"
client_secrets_file = os.path.join(pathlib.Path(__file__).parent.parent.parent.parent, "config/client_secret.json") # file that contains client id

# create flow object 
flow = Flow.from_client_secrets_file(
    client_secrets_file= client_secrets_file,
    scopes=["https://www.googleapis.com/auth/userinfo.email", "https://www.googleapis.com/auth/userinfo.profile", "openid"],
    redirect_uri = "http://127.0.0.1:5000/callback"
)

# connect to mysql database
# create connection object
def get_db_connection():
    conn = mysql.connector.connect(
        host = "localhost",
        user = "root",
        password = "123456",
        database = "Baitalon"
    )
    return conn
# parameter of function connect
# host = "localhost",  
# user 
# password
# database_name



#--------------------------------- Nhung thu phuc vu cac ham ben duoi-----------------------------------------


# func -> if user is not sign up --> not allow to access the main page
def login_is_required(f):   # decorator --> function that take another function
    def wrapper(*args, **kwargs):
        # check if user is authenticated --> if authenticated --> have google_id 
        if "google_id" not in session:
            abort(401)
        else:
            return f()
    return wrapper


# home page --> login or Sign up
@app.route("/login_page")
def login_page():
    session['previous_page'] = 'login'  
    return render_template("login.html")


@app.route("/signup")
def signup():
    session["previous_page"] = 'signup'  # save previous page to session
    return render_template("signup.html") 

# area when you choose sign up by google
@app.route("/process")
def process():
    authorization_url, state = flow.authorization_url()
    session["state"]= state
    return redirect(authorization_url)

# main page --> after login
@app.route("/main")
def main():
    return render_template('main.html')


# callback page when user login successfully --> get token , verify token and get user information
@app.route('/callback')
def callback():
    print("Callback function started")
    # exchange the authorization code for a token
    print("Fetching token...")
    print(f"Request URL: {request.url}")
    flow.fetch_token(authorization_response=request.url) # request.url --> the URL of the current request
    print("Token fetched")
    # check if session["state"] is equal to the state generated by flow
    print("Checking state...")
    if not session["state"] == request.args["state"]:
        print("State mismatch!")
        abort(401)

    print("State matched")
    request_session = requests.Session()            # Create an session -->  sử dụng requests.Session() để lưu trữ session và duy trì trạng thái đăng nhật.
    cached_session = CacheControl(request_session)  # Cache requests to avoid redundant API calls
    token_request = Request(session=cached_session) #Google Auth's --> create request object


    # get information
    print("Getting credentials...")
    credentials = flow.credentials
    print("Credentials obtained")
    
    print("Verifying token...")
    user_info = id_token.verify_oauth2_token(
        id_token = credentials.id_token,
        request= token_request,  # the request object that contains information about the current request
        audience= GOOGLE_CLIENT_ID,
        clock_skew_in_seconds=10 # the time difference between server and client -> what purpose -> to avoid the error of token expiration
    )
    print("Token verified")
    session['google_id'] = user_info['sub']  # sub --> subject --> unique identifier for the user
    session['email'] = user_info['email']
    session['google_name'] = user_info['name']

    # Save user info to data.json
    print("Saving user info to data.json...")
    user_data = {
        'google_id': session['google_id'],
        'email': session['email'],
        'name': session['google_name']
    }
    print(f"User data: {user_data}")
    
    json_file_path = os.path.join(pathlib.Path(__file__).parent.parent.parent, "data/data.json")
    print(f"JSON file path: {json_file_path}")
    os.makedirs(os.path.dirname(json_file_path), exist_ok=True)
    print("Directories created")
    
    try:
        # Read existing data
        print("Reading existing data...")
        if os.path.exists(json_file_path):
            with open(json_file_path, 'r') as f:
                try:
                    data = json.load(f)
                    print("Data loaded from file")
                except json.JSONDecodeError:
                    print("JSONDecodeError: File is empty or corrupted")
                    data = []
        else:
            print("File does not exist")
            data = []
        print(f"Existing data: {data}")
        
        # Update or append new user data
        print("Updating or appending new user data...")
        user_exists = False
        for i, user in enumerate(data):
            if user.get('google_id') == user_data['google_id']:
                print("User already exists")
                data[i] = user_data
                user_exists = True
                break
        
        if not user_exists:
            print("User does not exist, appending new user")
            data.append(user_data)
        print(f"New data: {data}")
            
        # Write back to file
        print("Writing back to file...")
        with open(json_file_path, 'w') as f:
            json.dump(data, f, indent=4)
            print("Data written to file")
            
    except Exception as e:
        print(f"Error saving to data.json: {str(e)}")

    # save info to database
    try:
        print("Connecting to database...")
        conn = get_db_connection()
        print("Connected to database")
        ex = conn.cursor()
        print("Cursor created")
        if session['previous_page'] == 'signup':
            print("Previous page is signup")
            # check if email exist
            ex.execute("SELECT * FROM User_info WHERE google_id = %s OR email = %s", 
                      (session['google_id'], session['email']))
            print("Executed query to check if user exists")
            exist_user = ex.fetchone()
            if exist_user:
                print("User exists")
                conn.close()
                print("Connection closed")
                return redirect(url_for("signup"))
            else:
                print("User does not exist")
                # if not exist --> add new user
                ex.execute("INSERT INTO User_info(google_id, email, User_name) VALUES(%s, %s, %s)", 
                          (session['google_id'], session['email'], session['google_name']))
                print("Executed query to insert new user")
                conn.commit()
                print("Changes committed")
                conn.close()
                print("Connection closed")
                return redirect(url_for("login_page"))  # redirect to login page
        else:  # Login flow
            print("Previous page is login")
            ex.execute("SELECT * FROM User_info WHERE google_id = %s AND email = %s", 
                      (session['google_id'], session['email']))
            print("Executed query to check if user exists")
            exist_user = ex.fetchone()
            if exist_user:
                print("User exists")
                # allow to access main page
                conn.close()
                print("Connection closed")
                return redirect(url_for("main"))
            else:
                print("User does not exist")
                conn.close()
                print("Connection closed")
                return redirect(url_for("signup"))
    except mysql.connector.Error as e:
        print(f"Error connection to database: {str(e)}")
        return redirect(url_for("signup"))


@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for("signup"))  


@app.errorhandler(404)
def page_not_found(e):
    return render_template('error.html', error_code=404, message="Page not found"), 404

@app.errorhandler(401)
def unauthorized(e):
    return render_template('error.html', error_code=401, message="Unauthorized access"), 401


if __name__ == "__main__":
    app.run(debug=True, port=5000)



'''
conn = get_db_connection()
        ex = conn.cursor()
        # check if email exist
        ex.execute("select * from User_info where google_id = %s || email = %s", (session['google_id'], session['email']) )
        exist_user = ex.fetchone()  # get head row of command query
        if exist_user:
            # if exist 
            conn.close()
            return redirect(url_for("signup"))
        else:
            # if not exist --> add new user but previous path í login page --> redirect to signup page
            ex.execute("insert into User_info(google_id, email, User_name) values (%s, %s, %s)", (session['google_id'], session['email'], session['email']))
            conn.commit() # save changes into database
            conn.close()
            return redirect(url_for("main"))
    except mysql.connector.Error as e:
        print(f"Error connection to database: {str(e)}")
        return redirect(url_for("signup"))
        
'''